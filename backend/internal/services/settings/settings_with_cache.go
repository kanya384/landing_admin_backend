package settings

// Code generated by gowrap. DO NOT EDIT.
// template: ../../generated/wrappers/cache
// gowrap: http://github.com/hexdigest/gowrap

//go:generate gowrap gen -p landing_admin_backend/internal/services/settings -i Settings -t ../../generated/wrappers/cache -o settings_with_cache.go -l ""

import (
	"context"
	"landing_admin_backend/internal/domain"
	"landing_admin_backend/internal/services/memcache"
)

// SettingsWithCache implements Settings that is instrumented with logging
type SettingsWithCache struct {
	cache memcache.Cache
	_base Settings
}

// NewSettingsWithCache instruments an implementation of the Settings with simple logging
func NewSettingsWithCache(base Settings, cache memcache.Cache) SettingsWithCache {
	return SettingsWithCache{
		_base: base,
		cache: cache,
	}
}

// CreateOrUpdate implements Settings
func (_d SettingsWithCache) CreateOrUpdate(ctx context.Context, setting domain.Setting) (settingRes *domain.Setting, err error) {
	defer _d.cache.Delete("Settings")

	return _d._base.CreateOrUpdate(ctx, setting)
}

// Get implements Settings
func (_d SettingsWithCache) Get(ctx context.Context) (settings []*domain.Setting, err error) {
	cached, ok := _d.cache.Get("Settings")
	if ok {

		return cached.Value.([]*domain.Setting), err

	}
	res, err := _d._base.Get(ctx)
	if err != nil {
		return
	}
	_d.cache.Set("Settings", res)
	return res, err
}

// GetByName implements Settings
func (_d SettingsWithCache) GetByName(ctx context.Context, name string) (setting *domain.Setting, err error) {
	return _d._base.GetByName(ctx, name)
}
